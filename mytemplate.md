# 算法模板库 

---

## 目录 (Table of Contents)

- [算法模板库](#算法模板库)
  - [目录 (Table of Contents)](#目录-table-of-contents)
  - [基础算法](#基础算法)
  - [数据结构](#数据结构)
    - [并查集 (DSU) - 路径压缩 + 按秩序合并](#并查集-dsu---路径压缩--按秩序合并)
  - [字符串算法](#字符串算法)
  - [数学算法](#数学算法)
  - [图论](#图论)
  - [树算法](#树算法)
  - [动态规划](#动态规划)
  - [网络流](#网络流)
  - [匹配算法](#匹配算法)
  - [莫队算法](#莫队算法)
  - [高精度](#高精度)
  - [人工智能](#人工智能)


## 基础算法
<!-- 在这里开始添加你的“基础算法”模板，比如快读、二分、排序等 -->


## 数据结构
<!-- 在这里开始添加你的“数据结构”模板，比如并查集、线段树、平衡树等 -->
### 并查集 (DSU) - 路径压缩 + 按秩序合并

```cpp
struct dsu {
    vi fa, sz;
    dsu() {};
    dsu(int n) {
        init(n);
    }
    void init(int n) {
        fa.resize(n + 1);
        iota(fa.begin(), fa.end(), 0);
        sz.assign(n + 1, 1);
    }
    int find(int x) {
        while (x != fa[x]) {
            x = fa[x] = fa[fa[x]];
        }
        return x;
    }
    bool mg(int x, int y) {
        x = find(x), y = find(y);
        if (x == y) return false;
        if (sz[x] < sz[y]) swap(x, y);
        fa[y] = x;
        sz[x] += sz[y];
        return true;
    }
    bool same(int x, int y) {
        return find(x) == find(y);
    }
    int siz(int x) {
        return sz[find(x)];
    }
};
```


## 字符串算法
<!-- 在这里开始添加你的“字符串算法”模板，比如KMP、AC自动机、后缀数组等 -->


## 数学算法
<!-- 在这里开始添加你的“数学算法”模板，比如快速幂、逆元、高斯消元等 -->


## 图论
<!-- 在这里开始添加你的“图论”模板，比如Dijkstra、最小生成树、Tarjan等 -->


## 树算法
<!-- 在这里开始添加你的“树算法”模板，比如LCA、点分治、树链剖分等 -->


## 动态规划
<!-- 在这里开始添加你的“动态规划”模板，比如背包DP、区间DP、插头DP等 -->


## 网络流
<!-- 在这里开始添加你的“网络流”模板，比如Dinic、MCMF等 -->


## 匹配算法
<!-- 在这里开始添加你的“匹配算法”模板，比如匈牙利算法、KM算法等 -->


## 莫队算法
<!-- 在这里开始添加你的“莫队算法”模板，比如普通莫队、带修改莫队等 -->


## 高精度
<!-- 在这里开始添加你的“高精度”模板，比如大整数类、分数类等 -->


## 人工智能
<!-- 在这里开始添加你的“人工智能”模板，比如Alpha-Beta剪枝、K-Means等 -->